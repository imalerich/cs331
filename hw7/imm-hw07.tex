\documentclass[12pt]{jhwhw}
\author{Ian Malerich}
\title{Com S 331: Homework 7}
\usepackage{amssymb, amsfonts, amsthm, mathtools, graphicx, breqn}
\usepackage{subfig, float, scrextend, setspace, soul}
\usepackage{tikz, subcaption, caption, graphviz}
\usetikzlibrary{arrows.meta, automata, positioning}

\onehalfspacing
\begin{document}
\raggedright

%% Problem 1
\problem{}

	Let $|x|_a$ be the number of occurrences of the symbol $a$ in the string $x$.
	\begin{itemize}
		\item 
			Define a context-free grammar for the language
			$L = \{w\in \{0,1\}^* : |w|_0 = |w|_1\}$.
		\item
			Given a formal proof that your grammar does indeed generate $L$.
	\end{itemize}

\solution

	$G = (\{S, Z, N\}, \{0,1\}, P, S)$ with productions $P$ given by

	\begin{align*}
		S &\rightarrow 0SNS\ |\ 1SZS \\
		S &\rightarrow \epsilon \\
		Z &\rightarrow 0 \\
		N &\rightarrow 1
	\end{align*}

	\begin{proof} 
		Let $w \not\in L$, want to show that $w$ is not generated by $G$. \\
		By definition of $L$, $w$ has an unequal number of 0's and 1's.
		Note that whenever $G$ generates a 0 there must be a corresponding 1 ($N$) generated
		alongside of it, further whenever $G$ generates a 1 there must be a corresponding
		0 ($Z$) generated alongside of it as well. Via this paring strategy, strings
		generated by $G$ are guaranteed to have equal number of 0's and 1's.
		Therefore, $w$ cannot be generated by $G$, thus we only need to determine
		whether or not G can generate EVERY string of equal 0's and 1's, and not just a subset.

		Let $w \in L$, want to show that $w$ can be generated by $G$. \\
		In order for $w$ to be generated by $G$ we need some pairing strategy 
		which maps to the format of $S$ for the strings in $G$. Note that there
		must be pairs of neighboring 0's and 1's in $w$, as $w$ contains an equal number
		of both. If not, $w$ is the empty string, and $G$ holds no problem. We will work
		in an inside out strategy, that is, working from the bottom of the generated tree
		up. Choose one such pair of neighboring 0's and 1's, this pair can be generated
		by $S$ using $0SNS\ |\ 1SZS$ with each $S\rightarrow \epsilon$. As these can be generated
		by S. In $w$, replace this pair with S, note that this working copy of $w$ now
		has $|w|_a-1$ pairs of a's and b's. Continue finding such pairs of 1's and 0's,
		but from now on, we can ignore any S (as we can use it instead of $\epsilon$ in the example
		above). We perform this process exactly $|w|_a$ times, until our string has been
		reduced to simply $S$, the starting non-terminal. Following this process in reverse
		order therefore generates $w$ using $G$.


	\end{proof}

%% Problem 2
\problem{}

	Define a NPDA for the language
	$L = \{a^nb^m : m,n\in \mathbb{N}, m\leq n\leq 2m\}$.

\solution

	$$
	\begin{tikzpicture}[baseline=(current axis.outer east)]
		\tikzset{vertex/.style = {shape=circle, draw, minimum size=3.0em}}
		\tikzset{edge/.style = {-{>[scale=1.75]},> = latex'}}
		\tikzset{loop/.style = {looseness=7}}

		\node[vertex, initial, initial where=left] (s0) at (0, 0) {$s_0$};

		\node[vertex] (q1) at (3, 0) {$q_1$};
		\node[vertex] (q2) at (3, -3) {$q_2$};
		\node[vertex] (F) at (8, 0) {$F$};
		\node[vertex, minimum size=2.6em] (_F) at (8, 0) {};

		\draw[-{>[scale=1.75]}] (s0) to[loop above] node[midway, above] {$a$ : push $a$} (s0);
		\draw[-{>[scale=1.75]}] (q1) to[loop above] node[midway, above] {$b$ : pop $a$} (q1);
		\draw[-{>[scale=1.75]}] (s0) to node[midway, above] {$\epsilon$} (q1);
		\draw[-{>[scale=1.75]}] (q1) to node[midway, above] {$\epsilon$ : empty stack} (F);

		\draw[-{>[scale=1.75]}] (q1) to[bend right] node[midway, left] {$b$ : pop $a$} (q2);
		\draw[-{>[scale=1.75]}] (q2) to[bend right] node[midway, right] {$\epsilon$ : pop $a$} (q1);

	\end{tikzpicture}
	$$

%% Problem 3
\problem{}

	Define a NPDA for the language
	$L = \{uv\in \{0,1\}^* : |u| = |v| \land u \neq v^R\}$.

\solution

	First note that $u\neq v^R \Rightarrow v\neq u^R$, we will take advantage of this
	by pushing $u$ on the stack, then, by reading the stack, we are reading $u^R$. Once
	the stack is empty, we know that $|u|=|v|$, thus we need only verify that when popping
	$u$ off the stack, we do so with at least one different character than what was found
	on the stack. Below, $B$ represents the 'bad' state, where $v$ has not yet proven itself
	unequal to $u^R$, as soon as we pop something different then we read, we enter $G$,
	the 'good' state, here we can read anything until the stack is empty, and enter our 
	final state.

	$$
	\begin{tikzpicture}[baseline=(current axis.outer east)]
		\tikzset{vertex/.style = {shape=circle, draw, minimum size=3.0em}}
		\tikzset{edge/.style = {-{>[scale=1.75]},> = latex'}}
		\tikzset{loop/.style = {looseness=7}}

		\node[vertex, initial, initial where=left] (s0) at (0, 0) {$s_0$};

		\node[vertex] (B) at (3, 0) {$B$};
		\node[vertex] (G) at (7, 0) {$G$};
		\node[vertex] (F) at (11.5, 0) {$F$};
		\node[vertex, minimum size=2.6em] (_F) at (11.5, 0) {};

		\draw[-{>[scale=1.75]}] (s0) to[loop above] node[midway, above] 
			{$0$ : push $0$} (s0);
		\draw[-{>[scale=1.75]}] (s0) to[loop below] node[midway, below] 
			{$1$ : push $1$} (s0);

		\draw[-{>[scale=1.75]}] (B) to[loop above] node[midway, above] 
			{$0$ : pop $0$} (B);
		\draw[-{>[scale=1.75]}] (B) to[loop below] node[midway, below] 
			{$1$ : pop $1$} (B);

		\draw[-{>[scale=1.75]}] (G) to[loop above] node[midway, above] 
			{$\{0,1\}$ : pop $\{0,1\}$} (G);

		\draw[-{>[scale=1.75]}] (s0) to node[midway, above] {$\epsilon$} (B);
		\draw[-{>[scale=1.75]}] (B) to[bend right] node[midway, below] {$0$ : pop $1$} (G);
		\draw[-{>[scale=1.75]}] (B) to[bend left] node[midway, above] {$1$ : pop $0$} (G);
		\draw[-{>[scale=1.75]}] (G) to node[midway, above] {$\epsilon$ : empty stack} (F);

	\end{tikzpicture}
	$$

\end{document}
